"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ripple_address_codec_1 = require("@transia/ripple-address-codec");
const ripple_binary_codec_1 = require("@transia/ripple-binary-codec");
const errors_1 = require("../errors");
const flags_1 = require("../models/utils/flags");
const getFeeXrp_1 = require("./getFeeXrp");
const LEDGER_OFFSET = 20;
const RESTRICTED_NETWORKS = 1024;
function autofill(transaction, signersCount) {
    return __awaiter(this, void 0, void 0, function* () {
        const tx = Object.assign({}, transaction);
        setValidAddresses(tx);
        (0, flags_1.setTransactionFlagsToNumber)(tx);
        const promises = [];
        if (this.networkID > RESTRICTED_NETWORKS && tx.NetworkID == null) {
            tx.NetworkID = this.networkID;
        }
        if (tx.Sequence == null) {
            promises.push(setNextValidSequenceNumber(this, tx));
        }
        if (tx.LastLedgerSequence == null) {
            promises.push(setLatestValidatedLedgerSequence(this, tx));
        }
        if (tx.TransactionType === 'AccountDelete') {
            promises.push(checkAccountDeleteBlockers(this, tx));
        }
        yield Promise.all(promises).then(() => tx);
        if (tx.Fee == null) {
            yield calculateFeePerTransactionType(this, tx, signersCount);
        }
        return tx;
    });
}
function setValidAddresses(tx) {
    validateAccountAddress(tx, 'Account', 'SourceTag');
    if (tx['Destination'] != null) {
        validateAccountAddress(tx, 'Destination', 'DestinationTag');
    }
    convertToClassicAddress(tx, 'Authorize');
    convertToClassicAddress(tx, 'Unauthorize');
    convertToClassicAddress(tx, 'Owner');
    convertToClassicAddress(tx, 'RegularKey');
}
function validateAccountAddress(tx, accountField, tagField) {
    const { classicAccount, tag } = getClassicAccountAndTag(tx[accountField]);
    tx[accountField] = classicAccount;
    if (tag != null && tag !== false) {
        if (tx[tagField] && tx[tagField] !== tag) {
            throw new errors_1.ValidationError(`The ${tagField}, if present, must match the tag of the ${accountField} X-address`);
        }
        tx[tagField] = tag;
    }
}
function getClassicAccountAndTag(Account, expectedTag) {
    if ((0, ripple_address_codec_1.isValidXAddress)(Account)) {
        const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(Account);
        if (expectedTag != null && classic.tag !== expectedTag) {
            throw new errors_1.ValidationError('address includes a tag that does not match the tag specified in the transaction');
        }
        return {
            classicAccount: classic.classicAddress,
            tag: classic.tag,
        };
    }
    return {
        classicAccount: Account,
        tag: expectedTag,
    };
}
function convertToClassicAddress(tx, fieldName) {
    const account = tx[fieldName];
    if (typeof account === 'string') {
        const { classicAccount } = getClassicAccountAndTag(account);
        tx[fieldName] = classicAccount;
    }
}
function setNextValidSequenceNumber(client, tx) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = {
            command: 'account_info',
            account: tx.Account,
            ledger_index: 'current',
        };
        const data = yield client.request(request);
        tx.Sequence = data.result.account_data.Sequence;
    });
}
function calculateFeePerTransactionType(client, tx, signersCount = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        const copyTx = Object.assign({}, tx);
        copyTx.SigningPubKey = ``;
        copyTx.Fee = `0`;
        const tx_blob = (0, ripple_binary_codec_1.encode)(copyTx);
        tx.Fee = yield (0, getFeeXrp_1.getFeeEstimateXrp)(client, tx_blob, signersCount);
    });
}
function setLatestValidatedLedgerSequence(client, tx) {
    return __awaiter(this, void 0, void 0, function* () {
        const ledgerSequence = yield client.getLedgerIndex();
        tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET;
    });
}
function checkAccountDeleteBlockers(client, tx) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = {
            command: 'account_objects',
            account: tx.Account,
            ledger_index: 'validated',
            deletion_blockers_only: true,
        };
        const response = yield client.request(request);
        return new Promise((resolve, reject) => {
            if (response.result.account_objects.length > 0) {
                reject(new errors_1.XrplError(`Account ${tx.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`, response.result.account_objects));
            }
            resolve();
        });
    });
}
exports.default = autofill;
//# sourceMappingURL=autofill.js.map