"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexHookParameters = exports.calculateHookOn = void 0;
const ripple_binary_codec_1 = require("@transia/ripple-binary-codec");
const errors_1 = require("../errors");
function calculateHookOn(arr) {
    let hash = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff';
    arr.forEach((nth) => {
        if (typeof nth !== 'string') {
            throw new errors_1.XrplError(`HookOn transaction type must be string`);
        }
        if (!ripple_binary_codec_1.TRANSACTION_TYPES.includes(String(nth))) {
            throw new errors_1.XrplError(`invalid transaction type '${String(nth)}' in HookOn array`);
        }
        const tts = ripple_binary_codec_1.TRANSACTION_TYPE_MAP;
        let value = BigInt(hash);
        value ^= BigInt(1) << BigInt(tts[nth]);
        hash = `0x${value.toString(16)}`;
    });
    hash = hash.replace('0x', '');
    hash = hash.padStart(64, '0');
    return hash.toUpperCase();
}
exports.calculateHookOn = calculateHookOn;
function isHex(value) {
    return /^[0-9A-F]+$/iu.test(value);
}
function hexValue(value) {
    return Buffer.from(value, 'utf8').toString('hex').toUpperCase();
}
function hexHookParameters(data) {
    const hookParameters = [];
    for (const parameter of data) {
        let hookPName = parameter.HookParameter.HookParameterName;
        let hookPValue = parameter.HookParameter.HookParameterValue;
        if (!isHex(hookPName)) {
            hookPName = hexValue(hookPName);
        }
        if (!isHex(hookPValue)) {
            hookPValue = hexValue(hookPValue);
        }
        hookParameters.push({
            HookParameter: {
                HookParameterName: hookPName,
                HookParameterValue: hookPValue,
            },
        });
    }
    return hookParameters;
}
exports.hexHookParameters = hexHookParameters;
//# sourceMappingURL=hooks.js.map