"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.currencyUTF8ToHex = exports.hexToBytes = exports.currencyHexToUTF8 = exports.isLPToken = exports.stringToAllCaps = exports.stringToUTF32Bytes = exports.stringToUTF16Bytes = exports.stringToUTF8Bytes = exports.bytesToHex = exports.toHex = exports.fromHex = void 0;
const currencyHexToUTF8 = (code) => {
    try {
        if (code.length === 3 || code.length === 4)
            return code;
        let decoded = new TextDecoder().decode(hexToBytes(code));
        let padNull = decoded.length;
        while (decoded.charAt(padNull - 1) === '\0')
            padNull--;
        return decoded.slice(0, padNull);
    }
    catch (error) {
        return code;
    }
};
exports.currencyHexToUTF8 = currencyHexToUTF8;
const hexToBytes = (hex) => {
    let bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i !== bytes.length; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
    }
    return bytes;
};
exports.hexToBytes = hexToBytes;
const currencyUTF8ToHex = (code) => {
    if (/^[a-zA-Z0-9?!@#$%^&*<>(){}[\]|\]{}]{3}$/.test(code))
        return code;
    if (/^[A-Z0-9]{40}$/.test(code))
        return code;
    let hex = '';
    for (let i = 0; i < code.length; i++) {
        hex += code.charCodeAt(i).toString(16);
    }
    return hex.toUpperCase().padEnd(40, '0');
};
exports.currencyUTF8ToHex = currencyUTF8ToHex;
function fromHex(hex, str) {
    try {
        str = decodeURIComponent(hex.replace(/(..)/g, '%$1'));
    }
    catch (e) {
        str = hex;
        console.log('invalid hex input: ' + hex);
    }
    console.log(str);
    return str;
}
exports.fromHex = fromHex;
function toHex(str, hex) {
    try {
        hex = unescape(encodeURIComponent(str))
            .split('')
            .map(function (v) {
            return v.charCodeAt(0).toString(16);
        })
            .join('');
    }
    catch (e) {
        hex = str;
        console.log('invalid text input: ' + str);
    }
    console.log(hex);
    return hex;
}
exports.toHex = toHex;
//main( 'testnet' , )
// This is the same for all of the below, and
// you probably won't need it except for debugging
// in most cases.
function bytesToHex(bytes) {
    return Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
}
exports.bytesToHex = bytesToHex;
// You almost certainly want UTF-8, which is
// now natively supported:
function stringToUTF8Bytes(string) {
    return new TextEncoder().encode(string);
}
exports.stringToUTF8Bytes = stringToUTF8Bytes;
// But you might want UTF-16 for some reason.
// .charCodeAt(index) will return the underlying
// UTF-16 code-units (not code-points!), so you
// just need to format them in whichever endian order you want.
function stringToUTF16Bytes(string, littleEndian) {
    const bytes = new Uint8Array(string.length * 2);
    // Using DataView is the only way to get a specific
    // endianness.
    const view = new DataView(bytes.buffer);
    for (let i = 0; i !== string.length; i++) {
        view.setUint16(i, string.charCodeAt(i), littleEndian);
    }
    return bytes;
}
exports.stringToUTF16Bytes = stringToUTF16Bytes;
function stringToUTF32Bytes(string, littleEndian) {
    const codepoints = Array.from(string, (c) => c.codePointAt(0));
    const bytes = new Uint8Array(codepoints.length * 4);
    // Using DataView is the only way to get a specific
    // endianness.
    const view = new DataView(bytes.buffer);
    for (let i = 0; i !== codepoints.length; i++) {
        view.setUint32(i, codepoints[i], littleEndian);
    }
    return bytes;
}
exports.stringToUTF32Bytes = stringToUTF32Bytes;
function stringToAllCaps(string) {
    var newString = '';
    for (let i = 0; i < string.length; i++) {
        if (string.charAt(i) !== string.charAt(i).toUpperCase()) {
            newString = newString + string.charAt(i).toUpperCase();
        }
        else {
            newString = newString + string.charAt(i);
        }
    }
    return newString;
}
exports.stringToAllCaps = stringToAllCaps;
const isLPToken = (code) => {
    if (code.length <= 3)
        return false;
    return BigInt('0x' + code) >> 152n === 0x03n;
};
exports.isLPToken = isLPToken;
//# sourceMappingURL=hexConversion.js.map