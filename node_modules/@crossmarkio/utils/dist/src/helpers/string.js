"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isXRPAddress = exports.ellipseNft = exports.ellipseAddress = exports.StringIdentifier = exports.StringTypeCheck = exports.Capitalize = exports.Truncate = exports.UUIDEncoding = exports.HexEncoding = void 0;
const UUIDEncoding = {
    toHex: (uuid) => {
        if (uuid.length % 2 !== 0) {
            throw new Error('Must have an even number to convert to bytes');
        }
        const numBytes = uuid.length / 2;
        const byteArray = new Uint8Array(numBytes);
        for (let i = 0; i < numBytes; i++) {
            let byte;
            const byteChar = uuid.substr(i * 2, 2);
            if (byteChar[0] === '-') {
                byte = (parseInt(`0${byteChar[1]}`, 16) * -1) & 0xff;
            }
            else if (byteChar[1] === '-') {
                byte = parseInt(byteChar[0], 16);
            }
            else {
                byte = parseInt(byteChar, 16);
            }
            byteArray[i] = byte;
        }
        return Array.from(byteArray, (byte) => {
            return `0${(byte & 0xff).toString(16)}`.slice(-2);
        }).join('');
    },
};
exports.UUIDEncoding = UUIDEncoding;
const HexEncoding = {
    toBinary: (hex) => Buffer.from(hex, 'hex'),
    toString: (hex) => Buffer.from(hex, 'hex').toString('utf8'),
    toHex: (text) => Buffer.from(text).toString('hex'),
    toUTF8: (hex) => {
        const buffer = Buffer.from(hex, 'hex');
        const isValid = Buffer.compare(Buffer.from(buffer.toString(), 'utf8'), buffer) === 0;
        if (!isValid)
            throw 'not a valid buffer';
        return buffer.toString('utf8');
    },
};
exports.HexEncoding = HexEncoding;
const Truncate = (fullString, string_length) => {
    if (fullString.length <= string_length) {
        return fullString;
    }
    const separator = '...';
    const separator_length = separator.length;
    const charsToShow = string_length - separator_length;
    const frontChars = Math.ceil(charsToShow / 2);
    const backChars = Math.floor(charsToShow / 2);
    return (fullString.slice(0, frontChars) +
        separator +
        fullString.slice(fullString.length - backChars, fullString.length));
};
exports.Truncate = Truncate;
const Capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
exports.Capitalize = Capitalize;
const StringTypeCheck = {
    isValidUUID: (input) => {
        // TODO: fix eslint error
        // eslint-disable-next-line prefer-regex-literals,no-control-regex
        const uuidv4RegExp = new RegExp('^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$', 'i');
        return uuidv4RegExp.test(input);
    },
    isValidURL: (input) => {
        // TODO: fix eslint error
        // eslint-disable-next-line prefer-regex-literals,no-control-regex
        const urlRegExp = new RegExp('^https://[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9].[a-zA-Z]{1,}[?/]{0,3}[^\r\n\t]+');
        return urlRegExp.test(input);
    },
    isValidAmount: (input) => {
        // TODO: fix eslint error
        // eslint-disable-next-line prefer-regex-literals,no-control-regex
        const amountRegExp = new RegExp(/^(?![0.]+$)\d+(\.\d{1,15})?$/gm);
        return amountRegExp.test(input);
    },
    isValidHash: (input) => {
        // TODO: fix eslint error
        // eslint-disable-next-line prefer-regex-literals,no-control-regex
        const hashRegExp = new RegExp('^[A-F0-9]{64}$', 'i');
        return hashRegExp.test(input);
    },
};
exports.StringTypeCheck = StringTypeCheck;
const StringIdentifier = (str) => {
    let crc = 0xffffffff;
    for (let i = 0; i < str.length; i++) {
        crc ^= str.charCodeAt(i);
        for (let bit = 0; bit < 8; bit++) {
            if ((crc & 1) !== 0)
                crc = (crc >>> 1) ^ 0xedb88320;
            else
                crc >>>= 1;
        }
    }
    return ~crc;
};
exports.StringIdentifier = StringIdentifier;
const ellipseAddress = (address, char) => {
    let length = char || 6;
    return address.slice(0, length) + '...' + address.slice(address.length - length, address.length);
};
exports.ellipseAddress = ellipseAddress;
const ellipseNft = (id) => id.slice(0, 16) + '...' + id.slice(id.length - 16, id.length);
exports.ellipseNft = ellipseNft;
const isXRPAddress = (address) => {
    let regex = 'r[0-9a-zA-Z]{24,34}';
    return new RegExp(regex, 'g').test(address);
};
exports.isXRPAddress = isXRPAddress;
//# sourceMappingURL=string.js.map